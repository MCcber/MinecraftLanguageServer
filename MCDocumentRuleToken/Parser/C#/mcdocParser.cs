//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from D:/C#Project/MinecraftLanguageServer/MCDocumentRule/mcdocParser.g4 by ANTLR 4.13.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.2")]
[System.CLSCompliant(false)]
public partial class mcdocParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		WS=1, As=2, At=3, QuestionMark=4, Dot=5, TypeKey=6, StructKeyType=7, Inject=8, 
		Enum=9, Use=10, To=11, Dispatch=12, Fallback=13, None=14, Unknown=15, 
		Parent=16, Key=17, Plus=18, Remainder=19, Equal=20, Sharp=21, SquareBrackets=22, 
		LeftSquareBracket=23, RightSquareBracket=24, RoundBrackets=25, LeftRoundBracket=26, 
		RightRoundBracket=27, CurlyBrackets=28, LeftCurlyBracket=29, RightCurlyBracket=30, 
		AngleBrackets=31, LeftAngleBracket=32, RightAngleBracket=33, LogicalOR=34, 
		Comma=35, DoubleColon=36, ColonMark=37, TripleDot=38, DoubleDot=39, ByteKeyType=40, 
		IntKeyType=41, LongKeyType=42, StringKeyType=43, BooleanKeyType=44, ShortKeyType=45, 
		FloatKeyType=46, DoubleKeyType=47, Any=48, BoolValue=49, DocCommentary=50, 
		Commentary=51, DoubleQuotes=52, Integer=53, Float=54, PositiveInteger=55, 
		IntTypedUnit=56, FloatTypedUnit=57, IntegerRange=58, FloatRange=59, Identifier=60, 
		String=61, ResourceLocationChar=62, ResourceLocation=63, PathSegment=64, 
		Path=65;
	public const int
		RULE_logicalOR = 0, RULE_path = 1, RULE_resourceLocation = 2, RULE_at = 3, 
		RULE_as = 4, RULE_dot = 5, RULE_baseDataType = 6, RULE_keywordType = 7, 
		RULE_questionMark = 8, RULE_typeKey = 9, RULE_structKeyType = 10, RULE_inject = 11, 
		RULE_enum = 12, RULE_use = 13, RULE_dispatch = 14, RULE_doubleDot = 15, 
		RULE_tripleDot = 16, RULE_integer = 17, RULE_float = 18, RULE_string = 19, 
		RULE_integerRange = 20, RULE_identifier = 21, RULE_boolValue = 22, RULE_commentary = 23, 
		RULE_docCommentary = 24, RULE_typedNumber = 25, RULE_stringType = 26, 
		RULE_literalType = 27, RULE_numericType = 28, RULE_primitiveArrayType = 29, 
		RULE_listType = 30, RULE_tupleType = 31, RULE_enumMemberType = 32, RULE_enumValue = 33, 
		RULE_enumField = 34, RULE_enumBlock = 35, RULE_enumType = 36, RULE_prelim = 37, 
		RULE_referenceType = 38, RULE_dispatcherType = 39, RULE_unionType = 40, 
		RULE_staticIndexKey = 41, RULE_accessor = 42, RULE_accessorKey = 43, RULE_dynamicIndex = 44, 
		RULE_index = 45, RULE_indexBody = 46, RULE_indexingOnAType = 47, RULE_typeArgBlock = 48, 
		RULE_unAttributedType = 49, RULE_typeSentence = 50, RULE_positionalValues = 51, 
		RULE_namedValue = 52, RULE_namedValues = 53, RULE_treeBody = 54, RULE_treeValue = 55, 
		RULE_value = 56, RULE_attribute = 57, RULE_dispatchStatement = 58, RULE_structInjection = 59, 
		RULE_enumInjection = 60, RULE_injection = 61, RULE_useStatement = 62, 
		RULE_typeParam = 63, RULE_typeParamBlock = 64, RULE_typeAlias = 65, RULE_structKey = 66, 
		RULE_structField = 67, RULE_structBlock = 68, RULE_struct = 69, RULE_file = 70;
	public static readonly string[] ruleNames = {
		"logicalOR", "path", "resourceLocation", "at", "as", "dot", "baseDataType", 
		"keywordType", "questionMark", "typeKey", "structKeyType", "inject", "enum", 
		"use", "dispatch", "doubleDot", "tripleDot", "integer", "float", "string", 
		"integerRange", "identifier", "boolValue", "commentary", "docCommentary", 
		"typedNumber", "stringType", "literalType", "numericType", "primitiveArrayType", 
		"listType", "tupleType", "enumMemberType", "enumValue", "enumField", "enumBlock", 
		"enumType", "prelim", "referenceType", "dispatcherType", "unionType", 
		"staticIndexKey", "accessor", "accessorKey", "dynamicIndex", "index", 
		"indexBody", "indexingOnAType", "typeArgBlock", "unAttributedType", "typeSentence", 
		"positionalValues", "namedValue", "namedValues", "treeBody", "treeValue", 
		"value", "attribute", "dispatchStatement", "structInjection", "enumInjection", 
		"injection", "useStatement", "typeParam", "typeParamBlock", "typeAlias", 
		"structKey", "structField", "structBlock", "struct", "file"
	};

	private static readonly string[] _LiteralNames = {
		null, null, "'as'", "'@'", "'?'", "'.'", "'type '", "'struct'", "'inject'", 
		"'enum'", "'use'", "'to'", "'dispatch'", "'%fallback'", "'%none'", "'%unknown'", 
		"'%parent'", "'%key'", "'+'", "'%'", "'='", "'#'", "'[]'", "'['", "']'", 
		"'()'", "'('", "')'", "'{}'", "'{'", "'}'", "'<>'", "'<'", "'>'", "'|'", 
		"','", "'::'", "':'", "'...'", "'..'", "'byte'", "'int'", "'long'", "'string'", 
		"'boolean'", "'short'", "'float'", "'double'", "'any'", null, null, null, 
		"'\"'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "WS", "As", "At", "QuestionMark", "Dot", "TypeKey", "StructKeyType", 
		"Inject", "Enum", "Use", "To", "Dispatch", "Fallback", "None", "Unknown", 
		"Parent", "Key", "Plus", "Remainder", "Equal", "Sharp", "SquareBrackets", 
		"LeftSquareBracket", "RightSquareBracket", "RoundBrackets", "LeftRoundBracket", 
		"RightRoundBracket", "CurlyBrackets", "LeftCurlyBracket", "RightCurlyBracket", 
		"AngleBrackets", "LeftAngleBracket", "RightAngleBracket", "LogicalOR", 
		"Comma", "DoubleColon", "ColonMark", "TripleDot", "DoubleDot", "ByteKeyType", 
		"IntKeyType", "LongKeyType", "StringKeyType", "BooleanKeyType", "ShortKeyType", 
		"FloatKeyType", "DoubleKeyType", "Any", "BoolValue", "DocCommentary", 
		"Commentary", "DoubleQuotes", "Integer", "Float", "PositiveInteger", "IntTypedUnit", 
		"FloatTypedUnit", "IntegerRange", "FloatRange", "Identifier", "String", 
		"ResourceLocationChar", "ResourceLocation", "PathSegment", "Path"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "mcdocParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static mcdocParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public mcdocParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public mcdocParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class LogicalORContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LogicalOR() { return GetToken(mcdocParser.LogicalOR, 0); }
		public LogicalORContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalOR; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterLogicalOR(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitLogicalOR(this);
		}
	}

	[RuleVersion(0)]
	public LogicalORContext logicalOR() {
		LogicalORContext _localctx = new LogicalORContext(Context, State);
		EnterRule(_localctx, 0, RULE_logicalOR);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 142;
			Match(LogicalOR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Path() { return GetToken(mcdocParser.Path, 0); }
		public PathContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_path; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterPath(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitPath(this);
		}
	}

	[RuleVersion(0)]
	public PathContext path() {
		PathContext _localctx = new PathContext(Context, State);
		EnterRule(_localctx, 2, RULE_path);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 144;
			Match(Path);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResourceLocationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ResourceLocation() { return GetToken(mcdocParser.ResourceLocation, 0); }
		public ResourceLocationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resourceLocation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterResourceLocation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitResourceLocation(this);
		}
	}

	[RuleVersion(0)]
	public ResourceLocationContext resourceLocation() {
		ResourceLocationContext _localctx = new ResourceLocationContext(Context, State);
		EnterRule(_localctx, 4, RULE_resourceLocation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 146;
			Match(ResourceLocation);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode At() { return GetToken(mcdocParser.At, 0); }
		public AtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_at; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterAt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitAt(this);
		}
	}

	[RuleVersion(0)]
	public AtContext at() {
		AtContext _localctx = new AtContext(Context, State);
		EnterRule(_localctx, 6, RULE_at);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 148;
			Match(At);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode As() { return GetToken(mcdocParser.As, 0); }
		public AsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_as; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterAs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitAs(this);
		}
	}

	[RuleVersion(0)]
	public AsContext @as() {
		AsContext _localctx = new AsContext(Context, State);
		EnterRule(_localctx, 8, RULE_as);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 150;
			Match(As);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(mcdocParser.Dot, 0); }
		public DotContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dot; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterDot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitDot(this);
		}
	}

	[RuleVersion(0)]
	public DotContext dot() {
		DotContext _localctx = new DotContext(Context, State);
		EnterRule(_localctx, 10, RULE_dot);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 152;
			Match(Dot);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BaseDataTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringKeyType() { return GetToken(mcdocParser.StringKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BooleanKeyType() { return GetToken(mcdocParser.BooleanKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ByteKeyType() { return GetToken(mcdocParser.ByteKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ShortKeyType() { return GetToken(mcdocParser.ShortKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntKeyType() { return GetToken(mcdocParser.IntKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FloatKeyType() { return GetToken(mcdocParser.FloatKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleKeyType() { return GetToken(mcdocParser.DoubleKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LongKeyType() { return GetToken(mcdocParser.LongKeyType, 0); }
		public BaseDataTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_baseDataType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterBaseDataType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitBaseDataType(this);
		}
	}

	[RuleVersion(0)]
	public BaseDataTypeContext baseDataType() {
		BaseDataTypeContext _localctx = new BaseDataTypeContext(Context, State);
		EnterRule(_localctx, 12, RULE_baseDataType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 154;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 280375465082880L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Any() { return GetToken(mcdocParser.Any, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BoolValue() { return GetToken(mcdocParser.BoolValue, 0); }
		public KeywordTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keywordType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterKeywordType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitKeywordType(this);
		}
	}

	[RuleVersion(0)]
	public KeywordTypeContext keywordType() {
		KeywordTypeContext _localctx = new KeywordTypeContext(Context, State);
		EnterRule(_localctx, 14, RULE_keywordType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 156;
			_la = TokenStream.LA(1);
			if ( !(_la==Any || _la==BoolValue) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuestionMarkContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(mcdocParser.QuestionMark, 0); }
		public QuestionMarkContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_questionMark; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterQuestionMark(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitQuestionMark(this);
		}
	}

	[RuleVersion(0)]
	public QuestionMarkContext questionMark() {
		QuestionMarkContext _localctx = new QuestionMarkContext(Context, State);
		EnterRule(_localctx, 16, RULE_questionMark);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			Match(QuestionMark);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeKeyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TypeKey() { return GetToken(mcdocParser.TypeKey, 0); }
		public TypeKeyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeKey; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTypeKey(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTypeKey(this);
		}
	}

	[RuleVersion(0)]
	public TypeKeyContext typeKey() {
		TypeKeyContext _localctx = new TypeKeyContext(Context, State);
		EnterRule(_localctx, 18, RULE_typeKey);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 160;
			Match(TypeKey);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructKeyTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StructKeyType() { return GetToken(mcdocParser.StructKeyType, 0); }
		public StructKeyTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structKeyType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterStructKeyType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitStructKeyType(this);
		}
	}

	[RuleVersion(0)]
	public StructKeyTypeContext structKeyType() {
		StructKeyTypeContext _localctx = new StructKeyTypeContext(Context, State);
		EnterRule(_localctx, 20, RULE_structKeyType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 162;
			Match(StructKeyType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InjectContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Inject() { return GetToken(mcdocParser.Inject, 0); }
		public InjectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inject; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterInject(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitInject(this);
		}
	}

	[RuleVersion(0)]
	public InjectContext inject() {
		InjectContext _localctx = new InjectContext(Context, State);
		EnterRule(_localctx, 22, RULE_inject);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 164;
			Match(Inject);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Enum() { return GetToken(mcdocParser.Enum, 0); }
		public EnumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enum; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterEnum(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitEnum(this);
		}
	}

	[RuleVersion(0)]
	public EnumContext @enum() {
		EnumContext _localctx = new EnumContext(Context, State);
		EnterRule(_localctx, 24, RULE_enum);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 166;
			Match(Enum);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Use() { return GetToken(mcdocParser.Use, 0); }
		public UseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_use; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterUse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitUse(this);
		}
	}

	[RuleVersion(0)]
	public UseContext use() {
		UseContext _localctx = new UseContext(Context, State);
		EnterRule(_localctx, 26, RULE_use);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 168;
			Match(Use);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DispatchContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dispatch() { return GetToken(mcdocParser.Dispatch, 0); }
		public DispatchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dispatch; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterDispatch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitDispatch(this);
		}
	}

	[RuleVersion(0)]
	public DispatchContext dispatch() {
		DispatchContext _localctx = new DispatchContext(Context, State);
		EnterRule(_localctx, 28, RULE_dispatch);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170;
			Match(Dispatch);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DoubleDotContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleDot() { return GetToken(mcdocParser.DoubleDot, 0); }
		public DoubleDotContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_doubleDot; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterDoubleDot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitDoubleDot(this);
		}
	}

	[RuleVersion(0)]
	public DoubleDotContext doubleDot() {
		DoubleDotContext _localctx = new DoubleDotContext(Context, State);
		EnterRule(_localctx, 30, RULE_doubleDot);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 172;
			Match(DoubleDot);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TripleDotContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TripleDot() { return GetToken(mcdocParser.TripleDot, 0); }
		public TripleDotContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tripleDot; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTripleDot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTripleDot(this);
		}
	}

	[RuleVersion(0)]
	public TripleDotContext tripleDot() {
		TripleDotContext _localctx = new TripleDotContext(Context, State);
		EnterRule(_localctx, 32, RULE_tripleDot);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 174;
			Match(TripleDot);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntegerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Integer() { return GetToken(mcdocParser.Integer, 0); }
		public IntegerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_integer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterInteger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitInteger(this);
		}
	}

	[RuleVersion(0)]
	public IntegerContext integer() {
		IntegerContext _localctx = new IntegerContext(Context, State);
		EnterRule(_localctx, 34, RULE_integer);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 176;
			Match(Integer);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FloatContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Float() { return GetToken(mcdocParser.Float, 0); }
		public FloatContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_float; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterFloat(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitFloat(this);
		}
	}

	[RuleVersion(0)]
	public FloatContext @float() {
		FloatContext _localctx = new FloatContext(Context, State);
		EnterRule(_localctx, 36, RULE_float);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 178;
			Match(Float);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(mcdocParser.String, 0); }
		public StringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitString(this);
		}
	}

	[RuleVersion(0)]
	public StringContext @string() {
		StringContext _localctx = new StringContext(Context, State);
		EnterRule(_localctx, 38, RULE_string);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 180;
			Match(String);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntegerRangeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntegerRange() { return GetToken(mcdocParser.IntegerRange, 0); }
		public IntegerRangeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_integerRange; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterIntegerRange(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitIntegerRange(this);
		}
	}

	[RuleVersion(0)]
	public IntegerRangeContext integerRange() {
		IntegerRangeContext _localctx = new IntegerRangeContext(Context, State);
		EnterRule(_localctx, 40, RULE_integerRange);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			Match(IntegerRange);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(mcdocParser.Identifier, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(Context, State);
		EnterRule(_localctx, 42, RULE_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 184;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BoolValue() { return GetToken(mcdocParser.BoolValue, 0); }
		public BoolValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_boolValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterBoolValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitBoolValue(this);
		}
	}

	[RuleVersion(0)]
	public BoolValueContext boolValue() {
		BoolValueContext _localctx = new BoolValueContext(Context, State);
		EnterRule(_localctx, 44, RULE_boolValue);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 186;
			Match(BoolValue);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommentaryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Commentary() { return GetToken(mcdocParser.Commentary, 0); }
		public CommentaryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commentary; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterCommentary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitCommentary(this);
		}
	}

	[RuleVersion(0)]
	public CommentaryContext commentary() {
		CommentaryContext _localctx = new CommentaryContext(Context, State);
		EnterRule(_localctx, 46, RULE_commentary);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 188;
			Match(Commentary);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DocCommentaryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DocCommentary() { return GetToken(mcdocParser.DocCommentary, 0); }
		public DocCommentaryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_docCommentary; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterDocCommentary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitDocCommentary(this);
		}
	}

	[RuleVersion(0)]
	public DocCommentaryContext docCommentary() {
		DocCommentaryContext _localctx = new DocCommentaryContext(Context, State);
		EnterRule(_localctx, 48, RULE_docCommentary);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 190;
			Match(DocCommentary);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedNumberContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntTypedUnit() { return GetToken(mcdocParser.IntTypedUnit, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FloatContext @float() {
			return GetRuleContext<FloatContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FloatTypedUnit() { return GetToken(mcdocParser.FloatTypedUnit, 0); }
		public TypedNumberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedNumber; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTypedNumber(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTypedNumber(this);
		}
	}

	[RuleVersion(0)]
	public TypedNumberContext typedNumber() {
		TypedNumberContext _localctx = new TypedNumberContext(Context, State);
		EnterRule(_localctx, 50, RULE_typedNumber);
		int _la;
		try {
			State = 200;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Integer:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 192;
				integer();
				State = 194;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IntTypedUnit) {
					{
					State = 193;
					Match(IntTypedUnit);
					}
				}

				}
				}
				break;
			case Float:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 196;
				@float();
				State = 198;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FloatTypedUnit) {
					{
					State = 197;
					Match(FloatTypedUnit);
					}
				}

				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringKeyType() { return GetToken(mcdocParser.StringKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AtContext at() {
			return GetRuleContext<AtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntegerRange() { return GetToken(mcdocParser.IntegerRange, 0); }
		public StringTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterStringType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitStringType(this);
		}
	}

	[RuleVersion(0)]
	public StringTypeContext stringType() {
		StringTypeContext _localctx = new StringTypeContext(Context, State);
		EnterRule(_localctx, 52, RULE_stringType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 202;
			Match(StringKeyType);
			State = 206;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==At) {
				{
				State = 203;
				at();
				State = 204;
				Match(IntegerRange);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BoolValueContext boolValue() {
			return GetRuleContext<BoolValueContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypedNumberContext typedNumber() {
			return GetRuleContext<TypedNumberContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public LiteralTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterLiteralType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitLiteralType(this);
		}
	}

	[RuleVersion(0)]
	public LiteralTypeContext literalType() {
		LiteralTypeContext _localctx = new LiteralTypeContext(Context, State);
		EnterRule(_localctx, 54, RULE_literalType);
		try {
			State = 212;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BoolValue:
				EnterOuterAlt(_localctx, 1);
				{
				State = 208;
				boolValue();
				}
				break;
			case Integer:
			case Float:
				EnterOuterAlt(_localctx, 2);
				{
				State = 209;
				typedNumber();
				}
				break;
			case String:
				EnterOuterAlt(_localctx, 3);
				{
				State = 210;
				@string();
				}
				break;
			case Identifier:
				EnterOuterAlt(_localctx, 4);
				{
				State = 211;
				identifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BaseDataTypeContext baseDataType() {
			return GetRuleContext<BaseDataTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AtContext at() {
			return GetRuleContext<AtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntegerRangeContext integerRange() {
			return GetRuleContext<IntegerRangeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public NumericTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numericType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterNumericType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitNumericType(this);
		}
	}

	[RuleVersion(0)]
	public NumericTypeContext numericType() {
		NumericTypeContext _localctx = new NumericTypeContext(Context, State);
		EnterRule(_localctx, 56, RULE_numericType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 214;
			baseDataType();
			State = 220;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==At) {
				{
				State = 215;
				at();
				State = 218;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case IntegerRange:
					{
					State = 216;
					integerRange();
					}
					break;
				case Integer:
					{
					State = 217;
					integer();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimitiveArrayTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SquareBrackets() { return GetToken(mcdocParser.SquareBrackets, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ByteKeyType() { return GetToken(mcdocParser.ByteKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntKeyType() { return GetToken(mcdocParser.IntKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LongKeyType() { return GetToken(mcdocParser.LongKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AtContext[] at() {
			return GetRuleContexts<AtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AtContext at(int i) {
			return GetRuleContext<AtContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] WS() { return GetTokens(mcdocParser.WS); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WS(int i) {
			return GetToken(mcdocParser.WS, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntegerRangeContext[] integerRange() {
			return GetRuleContexts<IntegerRangeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntegerRangeContext integerRange(int i) {
			return GetRuleContext<IntegerRangeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntegerContext[] integer() {
			return GetRuleContexts<IntegerContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntegerContext integer(int i) {
			return GetRuleContext<IntegerContext>(i);
		}
		public PrimitiveArrayTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primitiveArrayType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterPrimitiveArrayType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitPrimitiveArrayType(this);
		}
	}

	[RuleVersion(0)]
	public PrimitiveArrayTypeContext primitiveArrayType() {
		PrimitiveArrayTypeContext _localctx = new PrimitiveArrayTypeContext(Context, State);
		EnterRule(_localctx, 58, RULE_primitiveArrayType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 7696581394432L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 234;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==At) {
				{
				State = 223;
				at();
				State = 227;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==WS) {
					{
					{
					State = 224;
					Match(WS);
					}
					}
					State = 229;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 232;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case IntegerRange:
					{
					State = 230;
					integerRange();
					}
					break;
				case Integer:
					{
					State = 231;
					integer();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			State = 236;
			Match(SquareBrackets);
			State = 240;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==WS) {
				{
				{
				State = 237;
				Match(WS);
				}
				}
				State = 242;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 254;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==At) {
				{
				State = 243;
				at();
				State = 247;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==WS) {
					{
					{
					State = 244;
					Match(WS);
					}
					}
					State = 249;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 252;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case IntegerRange:
					{
					State = 250;
					integerRange();
					}
					break;
				case Integer:
					{
					State = 251;
					integer();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftSquareBracket() { return GetToken(mcdocParser.LeftSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext typeSentence() {
			return GetRuleContext<TypeSentenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightSquareBracket() { return GetToken(mcdocParser.RightSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AtContext at() {
			return GetRuleContext<AtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntegerRangeContext integerRange() {
			return GetRuleContext<IntegerRangeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ListTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterListType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitListType(this);
		}
	}

	[RuleVersion(0)]
	public ListTypeContext listType() {
		ListTypeContext _localctx = new ListTypeContext(Context, State);
		EnterRule(_localctx, 60, RULE_listType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 256;
			Match(LeftSquareBracket);
			State = 257;
			typeSentence();
			State = 258;
			Match(RightSquareBracket);
			State = 264;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==At) {
				{
				State = 259;
				at();
				State = 262;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case IntegerRange:
					{
					State = 260;
					integerRange();
					}
					break;
				case Integer:
					{
					State = 261;
					integer();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftSquareBracket() { return GetToken(mcdocParser.LeftSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext[] typeSentence() {
			return GetRuleContexts<TypeSentenceContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext typeSentence(int i) {
			return GetRuleContext<TypeSentenceContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(mcdocParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(mcdocParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightSquareBracket() { return GetToken(mcdocParser.RightSquareBracket, 0); }
		public TupleTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTupleType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTupleType(this);
		}
	}

	[RuleVersion(0)]
	public TupleTypeContext tupleType() {
		TupleTypeContext _localctx = new TupleTypeContext(Context, State);
		EnterRule(_localctx, 62, RULE_tupleType);
		int _la;
		try {
			int _alt;
			State = 284;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,18,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 266;
				Match(LeftSquareBracket);
				State = 267;
				typeSentence();
				State = 268;
				Match(Comma);
				State = 269;
				Match(RightSquareBracket);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 271;
				Match(LeftSquareBracket);
				State = 272;
				typeSentence();
				State = 275;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 273;
						Match(Comma);
						State = 274;
						typeSentence();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 277;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,16,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				State = 280;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 279;
					Match(Comma);
					}
				}

				State = 282;
				Match(RightSquareBracket);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumMemberTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringKeyType() { return GetToken(mcdocParser.StringKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ByteKeyType() { return GetToken(mcdocParser.ByteKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ShortKeyType() { return GetToken(mcdocParser.ShortKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntKeyType() { return GetToken(mcdocParser.IntKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LongKeyType() { return GetToken(mcdocParser.LongKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FloatKeyType() { return GetToken(mcdocParser.FloatKeyType, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleKeyType() { return GetToken(mcdocParser.DoubleKeyType, 0); }
		public EnumMemberTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumMemberType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterEnumMemberType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitEnumMemberType(this);
		}
	}

	[RuleVersion(0)]
	public EnumMemberTypeContext enumMemberType() {
		EnumMemberTypeContext _localctx = new EnumMemberTypeContext(Context, State);
		EnterRule(_localctx, 64, RULE_enumMemberType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 286;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 262783279038464L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypedNumberContext typedNumber() {
			return GetRuleContext<TypedNumberContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		public EnumValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterEnumValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitEnumValue(this);
		}
	}

	[RuleVersion(0)]
	public EnumValueContext enumValue() {
		EnumValueContext _localctx = new EnumValueContext(Context, State);
		EnterRule(_localctx, 66, RULE_enumValue);
		try {
			State = 290;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Integer:
			case Float:
				EnterOuterAlt(_localctx, 1);
				{
				State = 288;
				typedNumber();
				}
				break;
			case String:
				EnterOuterAlt(_localctx, 2);
				{
				State = 289;
				@string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(mcdocParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EnumValueContext enumValue() {
			return GetRuleContext<EnumValueContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrelimContext[] prelim() {
			return GetRuleContexts<PrelimContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrelimContext prelim(int i) {
			return GetRuleContext<PrelimContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeContext[] attribute() {
			return GetRuleContexts<AttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeContext attribute(int i) {
			return GetRuleContext<AttributeContext>(i);
		}
		public EnumFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterEnumField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitEnumField(this);
		}
	}

	[RuleVersion(0)]
	public EnumFieldContext enumField() {
		EnumFieldContext _localctx = new EnumFieldContext(Context, State);
		EnterRule(_localctx, 68, RULE_enumField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 295;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DocCommentary || _la==Commentary) {
				{
				{
				State = 292;
				prelim();
				}
				}
				State = 297;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 301;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Sharp) {
				{
				{
				State = 298;
				attribute();
				}
				}
				State = 303;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 304;
			identifier();
			State = 305;
			Match(Equal);
			State = 306;
			enumValue();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CurlyBrackets() { return GetToken(mcdocParser.CurlyBrackets, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftCurlyBracket() { return GetToken(mcdocParser.LeftCurlyBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EnumFieldContext[] enumField() {
			return GetRuleContexts<EnumFieldContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumFieldContext enumField(int i) {
			return GetRuleContext<EnumFieldContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightCurlyBracket() { return GetToken(mcdocParser.RightCurlyBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(mcdocParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(mcdocParser.Comma, i);
		}
		public EnumBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterEnumBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitEnumBlock(this);
		}
	}

	[RuleVersion(0)]
	public EnumBlockContext enumBlock() {
		EnumBlockContext _localctx = new EnumBlockContext(Context, State);
		EnterRule(_localctx, 70, RULE_enumBlock);
		int _la;
		try {
			int _alt;
			State = 323;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CurlyBrackets:
				EnterOuterAlt(_localctx, 1);
				{
				State = 308;
				Match(CurlyBrackets);
				}
				break;
			case LeftCurlyBracket:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 309;
				Match(LeftCurlyBracket);
				State = 310;
				enumField();
				State = 315;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,22,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 311;
						Match(Comma);
						State = 312;
						enumField();
						}
						} 
					}
					State = 317;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,22,Context);
				}
				State = 319;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 318;
					Match(Comma);
					}
				}

				State = 321;
				Match(RightCurlyBracket);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EnumContext @enum() {
			return GetRuleContext<EnumContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftRoundBracket() { return GetToken(mcdocParser.LeftRoundBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EnumMemberTypeContext enumMemberType() {
			return GetRuleContext<EnumMemberTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightRoundBracket() { return GetToken(mcdocParser.RightRoundBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EnumBlockContext enumBlock() {
			return GetRuleContext<EnumBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrelimContext prelim() {
			return GetRuleContext<PrelimContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public EnumTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterEnumType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitEnumType(this);
		}
	}

	[RuleVersion(0)]
	public EnumTypeContext enumType() {
		EnumTypeContext _localctx = new EnumTypeContext(Context, State);
		EnterRule(_localctx, 72, RULE_enumType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 326;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocCommentary || _la==Commentary) {
				{
				State = 325;
				prelim();
				}
			}

			State = 328;
			@enum();
			State = 329;
			Match(LeftRoundBracket);
			State = 330;
			enumMemberType();
			State = 331;
			Match(RightRoundBracket);
			State = 333;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 332;
				identifier();
				}
			}

			State = 335;
			enumBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrelimContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DocCommentaryContext docCommentary() {
			return GetRuleContext<DocCommentaryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommentaryContext commentary() {
			return GetRuleContext<CommentaryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeContext attribute() {
			return GetRuleContext<AttributeContext>(0);
		}
		public PrelimContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prelim; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterPrelim(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitPrelim(this);
		}
	}

	[RuleVersion(0)]
	public PrelimContext prelim() {
		PrelimContext _localctx = new PrelimContext(Context, State);
		EnterRule(_localctx, 74, RULE_prelim);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 339;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DocCommentary:
				{
				State = 337;
				docCommentary();
				}
				break;
			case Commentary:
				{
				State = 338;
				commentary();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 342;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,28,Context) ) {
			case 1:
				{
				State = 341;
				attribute();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReferenceTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Path() { return GetToken(mcdocParser.Path, 0); }
		public ReferenceTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referenceType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterReferenceType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitReferenceType(this);
		}
	}

	[RuleVersion(0)]
	public ReferenceTypeContext referenceType() {
		ReferenceTypeContext _localctx = new ReferenceTypeContext(Context, State);
		EnterRule(_localctx, 76, RULE_referenceType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 344;
			Match(Path);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DispatcherTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ResourceLocationContext resourceLocation() {
			return GetRuleContext<ResourceLocationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexBodyContext indexBody() {
			return GetRuleContext<IndexBodyContext>(0);
		}
		public DispatcherTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dispatcherType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterDispatcherType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitDispatcherType(this);
		}
	}

	[RuleVersion(0)]
	public DispatcherTypeContext dispatcherType() {
		DispatcherTypeContext _localctx = new DispatcherTypeContext(Context, State);
		EnterRule(_localctx, 78, RULE_dispatcherType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 346;
			resourceLocation();
			State = 347;
			indexBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnionTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RoundBrackets() { return GetToken(mcdocParser.RoundBrackets, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftRoundBracket() { return GetToken(mcdocParser.LeftRoundBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext[] typeSentence() {
			return GetRuleContexts<TypeSentenceContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext typeSentence(int i) {
			return GetRuleContext<TypeSentenceContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightRoundBracket() { return GetToken(mcdocParser.RightRoundBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LogicalORContext[] logicalOR() {
			return GetRuleContexts<LogicalORContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LogicalORContext logicalOR(int i) {
			return GetRuleContext<LogicalORContext>(i);
		}
		public UnionTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unionType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterUnionType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitUnionType(this);
		}
	}

	[RuleVersion(0)]
	public UnionTypeContext unionType() {
		UnionTypeContext _localctx = new UnionTypeContext(Context, State);
		EnterRule(_localctx, 80, RULE_unionType);
		int _la;
		try {
			int _alt;
			State = 365;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RoundBrackets:
				EnterOuterAlt(_localctx, 1);
				{
				State = 349;
				Match(RoundBrackets);
				}
				break;
			case LeftRoundBracket:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 350;
				Match(LeftRoundBracket);
				State = 351;
				typeSentence();
				State = 357;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 352;
						logicalOR();
						State = 353;
						typeSentence();
						}
						} 
					}
					State = 359;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
				}
				State = 361;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LogicalOR) {
					{
					State = 360;
					logicalOR();
					}
				}

				State = 363;
				Match(RightRoundBracket);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StaticIndexKeyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Fallback() { return GetToken(mcdocParser.Fallback, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode None() { return GetToken(mcdocParser.None, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Unknown() { return GetToken(mcdocParser.Unknown, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(mcdocParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(mcdocParser.String, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ResourceLocation() { return GetToken(mcdocParser.ResourceLocation, 0); }
		public StaticIndexKeyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_staticIndexKey; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterStaticIndexKey(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitStaticIndexKey(this);
		}
	}

	[RuleVersion(0)]
	public StaticIndexKeyContext staticIndexKey() {
		StaticIndexKeyContext _localctx = new StaticIndexKeyContext(Context, State);
		EnterRule(_localctx, 82, RULE_staticIndexKey);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 367;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & -5764607523034177536L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AccessorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AccessorKeyContext[] accessorKey() {
			return GetRuleContexts<AccessorKeyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AccessorKeyContext accessorKey(int i) {
			return GetRuleContext<AccessorKeyContext>(i);
		}
		public AccessorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_accessor; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterAccessor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitAccessor(this);
		}
	}

	[RuleVersion(0)]
	public AccessorContext accessor() {
		AccessorContext _localctx = new AccessorContext(Context, State);
		EnterRule(_localctx, 84, RULE_accessor);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 369;
			accessorKey();
			State = 373;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 3458764513820737536L) != 0)) {
				{
				{
				State = 370;
				accessorKey();
				}
				}
				State = 375;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AccessorKeyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Parent() { return GetToken(mcdocParser.Parent, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Key() { return GetToken(mcdocParser.Key, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(mcdocParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(mcdocParser.String, 0); }
		public AccessorKeyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_accessorKey; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterAccessorKey(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitAccessorKey(this);
		}
	}

	[RuleVersion(0)]
	public AccessorKeyContext accessorKey() {
		AccessorKeyContext _localctx = new AccessorKeyContext(Context, State);
		EnterRule(_localctx, 86, RULE_accessorKey);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 376;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 3458764513820737536L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DynamicIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftSquareBracket() { return GetToken(mcdocParser.LeftSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AccessorContext accessor() {
			return GetRuleContext<AccessorContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightSquareBracket() { return GetToken(mcdocParser.RightSquareBracket, 0); }
		public DynamicIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamicIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterDynamicIndex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitDynamicIndex(this);
		}
	}

	[RuleVersion(0)]
	public DynamicIndexContext dynamicIndex() {
		DynamicIndexContext _localctx = new DynamicIndexContext(Context, State);
		EnterRule(_localctx, 88, RULE_dynamicIndex);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 378;
			Match(LeftSquareBracket);
			State = 379;
			accessor();
			State = 380;
			Match(RightSquareBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StaticIndexKeyContext staticIndexKey() {
			return GetRuleContext<StaticIndexKeyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DynamicIndexContext dynamicIndex() {
			return GetRuleContext<DynamicIndexContext>(0);
		}
		public IndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterIndex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitIndex(this);
		}
	}

	[RuleVersion(0)]
	public IndexContext index() {
		IndexContext _localctx = new IndexContext(Context, State);
		EnterRule(_localctx, 90, RULE_index);
		try {
			State = 384;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Fallback:
			case None:
			case Unknown:
			case Identifier:
			case String:
			case ResourceLocation:
				EnterOuterAlt(_localctx, 1);
				{
				State = 382;
				staticIndexKey();
				}
				break;
			case LeftSquareBracket:
				EnterOuterAlt(_localctx, 2);
				{
				State = 383;
				dynamicIndex();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftSquareBracket() { return GetToken(mcdocParser.LeftSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexContext[] index() {
			return GetRuleContexts<IndexContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexContext index(int i) {
			return GetRuleContext<IndexContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightSquareBracket() { return GetToken(mcdocParser.RightSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(mcdocParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(mcdocParser.Comma, i);
		}
		public IndexBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterIndexBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitIndexBody(this);
		}
	}

	[RuleVersion(0)]
	public IndexBodyContext indexBody() {
		IndexBodyContext _localctx = new IndexBodyContext(Context, State);
		EnterRule(_localctx, 92, RULE_indexBody);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 386;
			Match(LeftSquareBracket);
			State = 387;
			index();
			State = 392;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,34,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 388;
					Match(Comma);
					State = 389;
					index();
					}
					} 
				}
				State = 394;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,34,Context);
			}
			State = 396;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Comma) {
				{
				State = 395;
				Match(Comma);
				}
			}

			State = 398;
			Match(RightSquareBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexingOnATypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IndexBodyContext indexBody() {
			return GetRuleContext<IndexBodyContext>(0);
		}
		public IndexingOnATypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexingOnAType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterIndexingOnAType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitIndexingOnAType(this);
		}
	}

	[RuleVersion(0)]
	public IndexingOnATypeContext indexingOnAType() {
		IndexingOnATypeContext _localctx = new IndexingOnATypeContext(Context, State);
		EnterRule(_localctx, 94, RULE_indexingOnAType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 400;
			indexBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeArgBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AngleBrackets() { return GetToken(mcdocParser.AngleBrackets, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftAngleBracket() { return GetToken(mcdocParser.LeftAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext[] typeSentence() {
			return GetRuleContexts<TypeSentenceContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext typeSentence(int i) {
			return GetRuleContext<TypeSentenceContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightAngleBracket() { return GetToken(mcdocParser.RightAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(mcdocParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(mcdocParser.Comma, i);
		}
		public TypeArgBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeArgBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTypeArgBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTypeArgBlock(this);
		}
	}

	[RuleVersion(0)]
	public TypeArgBlockContext typeArgBlock() {
		TypeArgBlockContext _localctx = new TypeArgBlockContext(Context, State);
		EnterRule(_localctx, 96, RULE_typeArgBlock);
		int _la;
		try {
			int _alt;
			State = 417;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AngleBrackets:
				EnterOuterAlt(_localctx, 1);
				{
				State = 402;
				Match(AngleBrackets);
				}
				break;
			case LeftAngleBracket:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 403;
				Match(LeftAngleBracket);
				State = 404;
				typeSentence();
				State = 409;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 405;
						Match(Comma);
						State = 406;
						typeSentence();
						}
						} 
					}
					State = 411;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
				}
				State = 413;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 412;
					Match(Comma);
					}
				}

				State = 415;
				Match(RightAngleBracket);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnAttributedTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public KeywordTypeContext keywordType() {
			return GetRuleContext<KeywordTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringTypeContext stringType() {
			return GetRuleContext<StringTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralTypeContext literalType() {
			return GetRuleContext<LiteralTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NumericTypeContext numericType() {
			return GetRuleContext<NumericTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrimitiveArrayTypeContext primitiveArrayType() {
			return GetRuleContext<PrimitiveArrayTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListTypeContext listType() {
			return GetRuleContext<ListTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleTypeContext tupleType() {
			return GetRuleContext<TupleTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumTypeContext enumType() {
			return GetRuleContext<EnumTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructContext @struct() {
			return GetRuleContext<StructContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReferenceTypeContext referenceType() {
			return GetRuleContext<ReferenceTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DispatcherTypeContext dispatcherType() {
			return GetRuleContext<DispatcherTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnionTypeContext unionType() {
			return GetRuleContext<UnionTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexingOnATypeContext indexingOnAType() {
			return GetRuleContext<IndexingOnATypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(mcdocParser.Comma, 0); }
		public UnAttributedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unAttributedType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterUnAttributedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitUnAttributedType(this);
		}
	}

	[RuleVersion(0)]
	public UnAttributedTypeContext unAttributedType() {
		UnAttributedTypeContext _localctx = new UnAttributedTypeContext(Context, State);
		EnterRule(_localctx, 98, RULE_unAttributedType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 432;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				{
				State = 419;
				keywordType();
				}
				break;
			case 2:
				{
				State = 420;
				stringType();
				}
				break;
			case 3:
				{
				State = 421;
				literalType();
				}
				break;
			case 4:
				{
				State = 422;
				numericType();
				}
				break;
			case 5:
				{
				State = 423;
				primitiveArrayType();
				}
				break;
			case 6:
				{
				State = 424;
				listType();
				}
				break;
			case 7:
				{
				State = 425;
				tupleType();
				}
				break;
			case 8:
				{
				State = 426;
				enumType();
				}
				break;
			case 9:
				{
				State = 427;
				@struct();
				}
				break;
			case 10:
				{
				State = 428;
				referenceType();
				}
				break;
			case 11:
				{
				State = 429;
				dispatcherType();
				}
				break;
			case 12:
				{
				State = 430;
				unionType();
				}
				break;
			case 13:
				{
				State = 431;
				indexingOnAType();
				}
				break;
			}
			State = 435;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,40,Context) ) {
			case 1:
				{
				State = 434;
				Match(Comma);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSentenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnAttributedTypeContext unAttributedType() {
			return GetRuleContext<UnAttributedTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeContext[] attribute() {
			return GetRuleContexts<AttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeContext attribute(int i) {
			return GetRuleContext<AttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexBodyContext[] indexBody() {
			return GetRuleContexts<IndexBodyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexBodyContext indexBody(int i) {
			return GetRuleContext<IndexBodyContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeArgBlockContext[] typeArgBlock() {
			return GetRuleContexts<TypeArgBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeArgBlockContext typeArgBlock(int i) {
			return GetRuleContext<TypeArgBlockContext>(i);
		}
		public TypeSentenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSentence; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTypeSentence(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTypeSentence(this);
		}
	}

	[RuleVersion(0)]
	public TypeSentenceContext typeSentence() {
		TypeSentenceContext _localctx = new TypeSentenceContext(Context, State);
		EnterRule(_localctx, 100, RULE_typeSentence);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 440;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Sharp) {
				{
				{
				State = 437;
				attribute();
				}
				}
				State = 442;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 443;
			unAttributedType();
			State = 448;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 6450839552L) != 0)) {
				{
				State = 446;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LeftSquareBracket:
					{
					State = 444;
					indexBody();
					}
					break;
				case AngleBrackets:
				case LeftAngleBracket:
					{
					State = 445;
					typeArgBlock();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 450;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PositionalValuesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ValueContext[] value() {
			return GetRuleContexts<ValueContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ValueContext value(int i) {
			return GetRuleContext<ValueContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(mcdocParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(mcdocParser.Comma, i);
		}
		public PositionalValuesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_positionalValues; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterPositionalValues(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitPositionalValues(this);
		}
	}

	[RuleVersion(0)]
	public PositionalValuesContext positionalValues() {
		PositionalValuesContext _localctx = new PositionalValuesContext(Context, State);
		EnterRule(_localctx, 102, RULE_positionalValues);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 451;
			value();
			State = 456;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,44,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 452;
					Match(Comma);
					State = 453;
					value();
					}
					} 
				}
				State = 458;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,44,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(mcdocParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringContext @string() {
			return GetRuleContext<StringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TreeValueContext treeValue() {
			return GetRuleContext<TreeValueContext>(0);
		}
		public NamedValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterNamedValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitNamedValue(this);
		}
	}

	[RuleVersion(0)]
	public NamedValueContext namedValue() {
		NamedValueContext _localctx = new NamedValueContext(Context, State);
		EnterRule(_localctx, 104, RULE_namedValue);
		try {
			State = 472;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,47,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 461;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case Identifier:
					{
					State = 459;
					identifier();
					}
					break;
				case String:
					{
					State = 460;
					@string();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 463;
				Match(Equal);
				State = 464;
				value();
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 468;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case Identifier:
					{
					State = 466;
					identifier();
					}
					break;
				case String:
					{
					State = 467;
					@string();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 470;
				treeValue();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamedValuesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamedValueContext[] namedValue() {
			return GetRuleContexts<NamedValueContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NamedValueContext namedValue(int i) {
			return GetRuleContext<NamedValueContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(mcdocParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(mcdocParser.Comma, i);
		}
		public NamedValuesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namedValues; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterNamedValues(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitNamedValues(this);
		}
	}

	[RuleVersion(0)]
	public NamedValuesContext namedValues() {
		NamedValuesContext _localctx = new NamedValuesContext(Context, State);
		EnterRule(_localctx, 106, RULE_namedValues);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 474;
			namedValue();
			State = 479;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,48,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 475;
					Match(Comma);
					State = 476;
					namedValue();
					}
					} 
				}
				State = 481;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,48,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TreeBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PositionalValuesContext positionalValues() {
			return GetRuleContext<PositionalValuesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(mcdocParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(mcdocParser.Comma, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NamedValuesContext namedValues() {
			return GetRuleContext<NamedValuesContext>(0);
		}
		public TreeBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_treeBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTreeBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTreeBody(this);
		}
	}

	[RuleVersion(0)]
	public TreeBodyContext treeBody() {
		TreeBodyContext _localctx = new TreeBodyContext(Context, State);
		EnterRule(_localctx, 108, RULE_treeBody);
		int _la;
		try {
			State = 496;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,52,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 482;
				positionalValues();
				State = 484;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 483;
					Match(Comma);
					}
				}

				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 486;
				namedValues();
				State = 488;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 487;
					Match(Comma);
					}
				}

				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 490;
				positionalValues();
				State = 491;
				Match(Comma);
				State = 492;
				namedValues();
				State = 494;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 493;
					Match(Comma);
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TreeValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftRoundBracket() { return GetToken(mcdocParser.LeftRoundBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightRoundBracket() { return GetToken(mcdocParser.RightRoundBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TreeBodyContext treeBody() {
			return GetRuleContext<TreeBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftSquareBracket() { return GetToken(mcdocParser.LeftSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightSquareBracket() { return GetToken(mcdocParser.RightSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftCurlyBracket() { return GetToken(mcdocParser.LeftCurlyBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightCurlyBracket() { return GetToken(mcdocParser.RightCurlyBracket, 0); }
		public TreeValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_treeValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTreeValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTreeValue(this);
		}
	}

	[RuleVersion(0)]
	public TreeValueContext treeValue() {
		TreeValueContext _localctx = new TreeValueContext(Context, State);
		EnterRule(_localctx, 110, RULE_treeValue);
		int _la;
		try {
			State = 513;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LeftRoundBracket:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 498;
				Match(LeftRoundBracket);
				State = 500;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 7)) & ~0x3f) == 0 && ((1L << (_la - 7)) & 387555849973612549L) != 0)) {
					{
					State = 499;
					treeBody();
					}
				}

				State = 502;
				Match(RightRoundBracket);
				}
				}
				break;
			case LeftSquareBracket:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 503;
				Match(LeftSquareBracket);
				State = 505;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 7)) & ~0x3f) == 0 && ((1L << (_la - 7)) & 387555849973612549L) != 0)) {
					{
					State = 504;
					treeBody();
					}
				}

				State = 507;
				Match(RightSquareBracket);
				}
				}
				break;
			case LeftCurlyBracket:
				EnterOuterAlt(_localctx, 3);
				{
				{
				State = 508;
				Match(LeftCurlyBracket);
				State = 510;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 7)) & ~0x3f) == 0 && ((1L << (_la - 7)) & 387555849973612549L) != 0)) {
					{
					State = 509;
					treeBody();
					}
				}

				State = 512;
				Match(RightCurlyBracket);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext typeSentence() {
			return GetRuleContext<TypeSentenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TreeValueContext treeValue() {
			return GetRuleContext<TreeValueContext>(0);
		}
		public ValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_value; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitValue(this);
		}
	}

	[RuleVersion(0)]
	public ValueContext value() {
		ValueContext _localctx = new ValueContext(Context, State);
		EnterRule(_localctx, 112, RULE_value);
		try {
			State = 517;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,57,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 515;
				typeSentence();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 516;
				treeValue();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Sharp() { return GetToken(mcdocParser.Sharp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftSquareBracket() { return GetToken(mcdocParser.LeftSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightSquareBracket() { return GetToken(mcdocParser.RightSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(mcdocParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TreeValueContext treeValue() {
			return GetRuleContext<TreeValueContext>(0);
		}
		public AttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterAttribute(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitAttribute(this);
		}
	}

	[RuleVersion(0)]
	public AttributeContext attribute() {
		AttributeContext _localctx = new AttributeContext(Context, State);
		EnterRule(_localctx, 114, RULE_attribute);
		try {
			State = 537;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,58,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 519;
				Match(Sharp);
				State = 520;
				Match(LeftSquareBracket);
				State = 521;
				identifier();
				State = 522;
				Match(RightSquareBracket);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 524;
				Match(Sharp);
				State = 525;
				Match(LeftSquareBracket);
				State = 526;
				identifier();
				State = 527;
				Match(Equal);
				State = 528;
				value();
				State = 529;
				Match(RightSquareBracket);
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				{
				State = 531;
				Match(Sharp);
				State = 532;
				Match(LeftSquareBracket);
				State = 533;
				identifier();
				State = 534;
				treeValue();
				State = 535;
				Match(RightSquareBracket);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DispatchStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DispatchContext dispatch() {
			return GetRuleContext<DispatchContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ResourceLocationContext resourceLocation() {
			return GetRuleContext<ResourceLocationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexBodyContext indexBody() {
			return GetRuleContext<IndexBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode To() { return GetToken(mcdocParser.To, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext typeSentence() {
			return GetRuleContext<TypeSentenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrelimContext prelim() {
			return GetRuleContext<PrelimContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeContext[] attribute() {
			return GetRuleContexts<AttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeContext attribute(int i) {
			return GetRuleContext<AttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeParamBlockContext typeParamBlock() {
			return GetRuleContext<TypeParamBlockContext>(0);
		}
		public DispatchStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dispatchStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterDispatchStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitDispatchStatement(this);
		}
	}

	[RuleVersion(0)]
	public DispatchStatementContext dispatchStatement() {
		DispatchStatementContext _localctx = new DispatchStatementContext(Context, State);
		EnterRule(_localctx, 116, RULE_dispatchStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 540;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DocCommentary || _la==Commentary) {
				{
				State = 539;
				prelim();
				}
			}

			State = 545;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Sharp) {
				{
				{
				State = 542;
				attribute();
				}
				}
				State = 547;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 548;
			dispatch();
			State = 549;
			resourceLocation();
			State = 550;
			indexBody();
			State = 552;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AngleBrackets || _la==LeftAngleBracket) {
				{
				State = 551;
				typeParamBlock();
				}
			}

			State = 554;
			Match(To);
			State = 555;
			typeSentence();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructInjectionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructKeyTypeContext structKeyType() {
			return GetRuleContext<StructKeyTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PathContext path() {
			return GetRuleContext<PathContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructBlockContext structBlock() {
			return GetRuleContext<StructBlockContext>(0);
		}
		public StructInjectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structInjection; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterStructInjection(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitStructInjection(this);
		}
	}

	[RuleVersion(0)]
	public StructInjectionContext structInjection() {
		StructInjectionContext _localctx = new StructInjectionContext(Context, State);
		EnterRule(_localctx, 118, RULE_structInjection);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 557;
			structKeyType();
			State = 558;
			path();
			State = 559;
			structBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumInjectionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Enum() { return GetToken(mcdocParser.Enum, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftRoundBracket() { return GetToken(mcdocParser.LeftRoundBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EnumTypeContext enumType() {
			return GetRuleContext<EnumTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightRoundBracket() { return GetToken(mcdocParser.RightRoundBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PathContext path() {
			return GetRuleContext<PathContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumBlockContext enumBlock() {
			return GetRuleContext<EnumBlockContext>(0);
		}
		public EnumInjectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumInjection; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterEnumInjection(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitEnumInjection(this);
		}
	}

	[RuleVersion(0)]
	public EnumInjectionContext enumInjection() {
		EnumInjectionContext _localctx = new EnumInjectionContext(Context, State);
		EnterRule(_localctx, 120, RULE_enumInjection);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 561;
			Match(Enum);
			State = 562;
			Match(LeftRoundBracket);
			State = 563;
			enumType();
			State = 564;
			Match(RightRoundBracket);
			State = 565;
			path();
			State = 566;
			enumBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InjectionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InjectContext inject() {
			return GetRuleContext<InjectContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumInjectionContext enumInjection() {
			return GetRuleContext<EnumInjectionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructInjectionContext structInjection() {
			return GetRuleContext<StructInjectionContext>(0);
		}
		public InjectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_injection; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterInjection(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitInjection(this);
		}
	}

	[RuleVersion(0)]
	public InjectionContext injection() {
		InjectionContext _localctx = new InjectionContext(Context, State);
		EnterRule(_localctx, 122, RULE_injection);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 568;
			inject();
			State = 571;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Enum:
				{
				State = 569;
				enumInjection();
				}
				break;
			case StructKeyType:
				{
				State = 570;
				structInjection();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UseContext use() {
			return GetRuleContext<UseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PathContext path() {
			return GetRuleContext<PathContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsContext @as() {
			return GetRuleContext<AsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public UseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_useStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterUseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitUseStatement(this);
		}
	}

	[RuleVersion(0)]
	public UseStatementContext useStatement() {
		UseStatementContext _localctx = new UseStatementContext(Context, State);
		EnterRule(_localctx, 124, RULE_useStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 573;
			use();
			State = 574;
			path();
			State = 578;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==As) {
				{
				State = 575;
				@as();
				State = 576;
				identifier();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeParamContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(mcdocParser.Identifier, 0); }
		public TypeParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeParam; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTypeParam(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTypeParam(this);
		}
	}

	[RuleVersion(0)]
	public TypeParamContext typeParam() {
		TypeParamContext _localctx = new TypeParamContext(Context, State);
		EnterRule(_localctx, 126, RULE_typeParam);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 580;
			Match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeParamBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AngleBrackets() { return GetToken(mcdocParser.AngleBrackets, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftAngleBracket() { return GetToken(mcdocParser.LeftAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeParamContext[] typeParam() {
			return GetRuleContexts<TypeParamContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeParamContext typeParam(int i) {
			return GetRuleContext<TypeParamContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightAngleBracket() { return GetToken(mcdocParser.RightAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(mcdocParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(mcdocParser.Comma, i);
		}
		public TypeParamBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeParamBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTypeParamBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTypeParamBlock(this);
		}
	}

	[RuleVersion(0)]
	public TypeParamBlockContext typeParamBlock() {
		TypeParamBlockContext _localctx = new TypeParamBlockContext(Context, State);
		EnterRule(_localctx, 128, RULE_typeParamBlock);
		int _la;
		try {
			int _alt;
			State = 597;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case AngleBrackets:
				EnterOuterAlt(_localctx, 1);
				{
				State = 582;
				Match(AngleBrackets);
				}
				break;
			case LeftAngleBracket:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 583;
				Match(LeftAngleBracket);
				State = 584;
				typeParam();
				State = 589;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,64,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 585;
						Match(Comma);
						State = 586;
						typeParam();
						}
						} 
					}
					State = 591;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,64,Context);
				}
				State = 593;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 592;
					Match(Comma);
					}
				}

				State = 595;
				Match(RightAngleBracket);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeAliasContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeKeyContext typeKey() {
			return GetRuleContext<TypeKeyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(mcdocParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext typeSentence() {
			return GetRuleContext<TypeSentenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrelimContext[] prelim() {
			return GetRuleContexts<PrelimContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrelimContext prelim(int i) {
			return GetRuleContext<PrelimContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeParamBlockContext typeParamBlock() {
			return GetRuleContext<TypeParamBlockContext>(0);
		}
		public TypeAliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeAlias; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterTypeAlias(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitTypeAlias(this);
		}
	}

	[RuleVersion(0)]
	public TypeAliasContext typeAlias() {
		TypeAliasContext _localctx = new TypeAliasContext(Context, State);
		EnterRule(_localctx, 130, RULE_typeAlias);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 602;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DocCommentary || _la==Commentary) {
				{
				{
				State = 599;
				prelim();
				}
				}
				State = 604;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 605;
			typeKey();
			State = 606;
			identifier();
			State = 608;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AngleBrackets || _la==LeftAngleBracket) {
				{
				State = 607;
				typeParamBlock();
				}
			}

			State = 610;
			Match(Equal);
			State = 611;
			typeSentence();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructKeyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(mcdocParser.String, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(mcdocParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftSquareBracket() { return GetToken(mcdocParser.LeftSquareBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext typeSentence() {
			return GetRuleContext<TypeSentenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightSquareBracket() { return GetToken(mcdocParser.RightSquareBracket, 0); }
		public StructKeyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structKey; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterStructKey(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitStructKey(this);
		}
	}

	[RuleVersion(0)]
	public StructKeyContext structKey() {
		StructKeyContext _localctx = new StructKeyContext(Context, State);
		EnterRule(_localctx, 132, RULE_structKey);
		try {
			State = 619;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case String:
				EnterOuterAlt(_localctx, 1);
				{
				State = 613;
				Match(String);
				}
				break;
			case Identifier:
				EnterOuterAlt(_localctx, 2);
				{
				State = 614;
				Match(Identifier);
				}
				break;
			case LeftSquareBracket:
				EnterOuterAlt(_localctx, 3);
				{
				{
				State = 615;
				Match(LeftSquareBracket);
				State = 616;
				typeSentence();
				State = 617;
				Match(RightSquareBracket);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructKeyContext structKey() {
			return GetRuleContext<StructKeyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ColonMark() { return GetToken(mcdocParser.ColonMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeSentenceContext typeSentence() {
			return GetRuleContext<TypeSentenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrelimContext[] prelim() {
			return GetRuleContexts<PrelimContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrelimContext prelim(int i) {
			return GetRuleContext<PrelimContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeContext[] attribute() {
			return GetRuleContexts<AttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AttributeContext attribute(int i) {
			return GetRuleContext<AttributeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public QuestionMarkContext questionMark() {
			return GetRuleContext<QuestionMarkContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TripleDotContext tripleDot() {
			return GetRuleContext<TripleDotContext>(0);
		}
		public StructFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterStructField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitStructField(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldContext structField() {
		StructFieldContext _localctx = new StructFieldContext(Context, State);
		EnterRule(_localctx, 134, RULE_structField);
		int _la;
		try {
			int _alt;
			State = 650;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,75,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 624;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==DocCommentary || _la==Commentary) {
					{
					{
					State = 621;
					prelim();
					}
					}
					State = 626;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 630;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Sharp) {
					{
					{
					State = 627;
					attribute();
					}
					}
					State = 632;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 633;
				structKey();
				State = 635;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==QuestionMark) {
					{
					State = 634;
					questionMark();
					}
				}

				State = 637;
				Match(ColonMark);
				State = 638;
				typeSentence();
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 643;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,73,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 640;
						attribute();
						}
						} 
					}
					State = 645;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,73,Context);
				}
				State = 647;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TripleDot) {
					{
					State = 646;
					tripleDot();
					}
				}

				State = 649;
				typeSentence();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CurlyBrackets() { return GetToken(mcdocParser.CurlyBrackets, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftCurlyBracket() { return GetToken(mcdocParser.LeftCurlyBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext[] structField() {
			return GetRuleContexts<StructFieldContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldContext structField(int i) {
			return GetRuleContext<StructFieldContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightCurlyBracket() { return GetToken(mcdocParser.RightCurlyBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(mcdocParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(mcdocParser.Comma, i);
		}
		public StructBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterStructBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitStructBlock(this);
		}
	}

	[RuleVersion(0)]
	public StructBlockContext structBlock() {
		StructBlockContext _localctx = new StructBlockContext(Context, State);
		EnterRule(_localctx, 136, RULE_structBlock);
		int _la;
		try {
			int _alt;
			State = 667;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CurlyBrackets:
				EnterOuterAlt(_localctx, 1);
				{
				State = 652;
				Match(CurlyBrackets);
				}
				break;
			case LeftCurlyBracket:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 653;
				Match(LeftCurlyBracket);
				State = 654;
				structField();
				State = 659;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,76,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 655;
						Match(Comma);
						State = 656;
						structField();
						}
						} 
					}
					State = 661;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,76,Context);
				}
				State = 663;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 662;
					Match(Comma);
					}
				}

				State = 665;
				Match(RightCurlyBracket);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructKeyTypeContext structKeyType() {
			return GetRuleContext<StructKeyTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructBlockContext structBlock() {
			return GetRuleContext<StructBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrelimContext[] prelim() {
			return GetRuleContexts<PrelimContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrelimContext prelim(int i) {
			return GetRuleContext<PrelimContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public StructContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_struct; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterStruct(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitStruct(this);
		}
	}

	[RuleVersion(0)]
	public StructContext @struct() {
		StructContext _localctx = new StructContext(Context, State);
		EnterRule(_localctx, 138, RULE_struct);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 672;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DocCommentary || _la==Commentary) {
				{
				{
				State = 669;
				prelim();
				}
				}
				State = 674;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 675;
			structKeyType();
			State = 677;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 676;
				identifier();
				}
			}

			State = 679;
			structBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructContext[] @struct() {
			return GetRuleContexts<StructContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructContext @struct(int i) {
			return GetRuleContext<StructContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumTypeContext[] enumType() {
			return GetRuleContexts<EnumTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnumTypeContext enumType(int i) {
			return GetRuleContext<EnumTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeAliasContext[] typeAlias() {
			return GetRuleContexts<TypeAliasContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeAliasContext typeAlias(int i) {
			return GetRuleContext<TypeAliasContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UseStatementContext[] useStatement() {
			return GetRuleContexts<UseStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UseStatementContext useStatement(int i) {
			return GetRuleContext<UseStatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InjectionContext[] injection() {
			return GetRuleContexts<InjectionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InjectionContext injection(int i) {
			return GetRuleContext<InjectionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DispatchStatementContext[] dispatchStatement() {
			return GetRuleContexts<DispatchStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DispatchStatementContext dispatchStatement(int i) {
			return GetRuleContext<DispatchStatementContext>(i);
		}
		public FileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_file; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.EnterFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ImcdocParserListener typedListener = listener as ImcdocParserListener;
			if (typedListener != null) typedListener.ExitFile(this);
		}
	}

	[RuleVersion(0)]
	public FileContext file() {
		FileContext _localctx = new FileContext(Context, State);
		EnterRule(_localctx, 140, RULE_file);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 689;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 3377699722631104L) != 0)) {
				{
				State = 687;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,81,Context) ) {
				case 1:
					{
					State = 681;
					@struct();
					}
					break;
				case 2:
					{
					State = 682;
					enumType();
					}
					break;
				case 3:
					{
					State = 683;
					typeAlias();
					}
					break;
				case 4:
					{
					State = 684;
					useStatement();
					}
					break;
				case 5:
					{
					State = 685;
					injection();
					}
					break;
				case 6:
					{
					State = 686;
					dispatchStatement();
					}
					break;
				}
				}
				State = 691;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,65,693,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,
		2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,
		2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,
		2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,
		2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,
		1,0,1,0,1,1,1,1,1,2,1,2,1,3,1,3,1,4,1,4,1,5,1,5,1,6,1,6,1,7,1,7,1,8,1,
		8,1,9,1,9,1,10,1,10,1,11,1,11,1,12,1,12,1,13,1,13,1,14,1,14,1,15,1,15,
		1,16,1,16,1,17,1,17,1,18,1,18,1,19,1,19,1,20,1,20,1,21,1,21,1,22,1,22,
		1,23,1,23,1,24,1,24,1,25,1,25,3,25,195,8,25,1,25,1,25,3,25,199,8,25,3,
		25,201,8,25,1,26,1,26,1,26,1,26,3,26,207,8,26,1,27,1,27,1,27,1,27,3,27,
		213,8,27,1,28,1,28,1,28,1,28,3,28,219,8,28,3,28,221,8,28,1,29,1,29,1,29,
		5,29,226,8,29,10,29,12,29,229,9,29,1,29,1,29,3,29,233,8,29,3,29,235,8,
		29,1,29,1,29,5,29,239,8,29,10,29,12,29,242,9,29,1,29,1,29,5,29,246,8,29,
		10,29,12,29,249,9,29,1,29,1,29,3,29,253,8,29,3,29,255,8,29,1,30,1,30,1,
		30,1,30,1,30,1,30,3,30,263,8,30,3,30,265,8,30,1,31,1,31,1,31,1,31,1,31,
		1,31,1,31,1,31,1,31,4,31,276,8,31,11,31,12,31,277,1,31,3,31,281,8,31,1,
		31,1,31,3,31,285,8,31,1,32,1,32,1,33,1,33,3,33,291,8,33,1,34,5,34,294,
		8,34,10,34,12,34,297,9,34,1,34,5,34,300,8,34,10,34,12,34,303,9,34,1,34,
		1,34,1,34,1,34,1,35,1,35,1,35,1,35,1,35,5,35,314,8,35,10,35,12,35,317,
		9,35,1,35,3,35,320,8,35,1,35,1,35,3,35,324,8,35,1,36,3,36,327,8,36,1,36,
		1,36,1,36,1,36,1,36,3,36,334,8,36,1,36,1,36,1,37,1,37,3,37,340,8,37,1,
		37,3,37,343,8,37,1,38,1,38,1,39,1,39,1,39,1,40,1,40,1,40,1,40,1,40,1,40,
		5,40,356,8,40,10,40,12,40,359,9,40,1,40,3,40,362,8,40,1,40,1,40,3,40,366,
		8,40,1,41,1,41,1,42,1,42,5,42,372,8,42,10,42,12,42,375,9,42,1,43,1,43,
		1,44,1,44,1,44,1,44,1,45,1,45,3,45,385,8,45,1,46,1,46,1,46,1,46,5,46,391,
		8,46,10,46,12,46,394,9,46,1,46,3,46,397,8,46,1,46,1,46,1,47,1,47,1,48,
		1,48,1,48,1,48,1,48,5,48,408,8,48,10,48,12,48,411,9,48,1,48,3,48,414,8,
		48,1,48,1,48,3,48,418,8,48,1,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,
		1,49,1,49,1,49,1,49,3,49,433,8,49,1,49,3,49,436,8,49,1,50,5,50,439,8,50,
		10,50,12,50,442,9,50,1,50,1,50,1,50,5,50,447,8,50,10,50,12,50,450,9,50,
		1,51,1,51,1,51,5,51,455,8,51,10,51,12,51,458,9,51,1,52,1,52,3,52,462,8,
		52,1,52,1,52,1,52,1,52,1,52,3,52,469,8,52,1,52,1,52,3,52,473,8,52,1,53,
		1,53,1,53,5,53,478,8,53,10,53,12,53,481,9,53,1,54,1,54,3,54,485,8,54,1,
		54,1,54,3,54,489,8,54,1,54,1,54,1,54,1,54,3,54,495,8,54,3,54,497,8,54,
		1,55,1,55,3,55,501,8,55,1,55,1,55,1,55,3,55,506,8,55,1,55,1,55,1,55,3,
		55,511,8,55,1,55,3,55,514,8,55,1,56,1,56,3,56,518,8,56,1,57,1,57,1,57,
		1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,
		1,57,3,57,538,8,57,1,58,3,58,541,8,58,1,58,5,58,544,8,58,10,58,12,58,547,
		9,58,1,58,1,58,1,58,1,58,3,58,553,8,58,1,58,1,58,1,58,1,59,1,59,1,59,1,
		59,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,61,1,61,1,61,3,61,572,8,61,1,62,
		1,62,1,62,1,62,1,62,3,62,579,8,62,1,63,1,63,1,64,1,64,1,64,1,64,1,64,5,
		64,588,8,64,10,64,12,64,591,9,64,1,64,3,64,594,8,64,1,64,1,64,3,64,598,
		8,64,1,65,5,65,601,8,65,10,65,12,65,604,9,65,1,65,1,65,1,65,3,65,609,8,
		65,1,65,1,65,1,65,1,66,1,66,1,66,1,66,1,66,1,66,3,66,620,8,66,1,67,5,67,
		623,8,67,10,67,12,67,626,9,67,1,67,5,67,629,8,67,10,67,12,67,632,9,67,
		1,67,1,67,3,67,636,8,67,1,67,1,67,1,67,1,67,5,67,642,8,67,10,67,12,67,
		645,9,67,1,67,3,67,648,8,67,1,67,3,67,651,8,67,1,68,1,68,1,68,1,68,1,68,
		5,68,658,8,68,10,68,12,68,661,9,68,1,68,3,68,664,8,68,1,68,1,68,3,68,668,
		8,68,1,69,5,69,671,8,69,10,69,12,69,674,9,69,1,69,1,69,3,69,678,8,69,1,
		69,1,69,1,70,1,70,1,70,1,70,1,70,1,70,5,70,688,8,70,10,70,12,70,691,9,
		70,1,70,0,0,71,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,
		88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,
		126,128,130,132,134,136,138,140,0,6,1,0,40,47,1,0,48,49,1,0,40,42,2,0,
		40,43,45,47,3,0,13,15,60,61,63,63,2,0,16,17,60,61,725,0,142,1,0,0,0,2,
		144,1,0,0,0,4,146,1,0,0,0,6,148,1,0,0,0,8,150,1,0,0,0,10,152,1,0,0,0,12,
		154,1,0,0,0,14,156,1,0,0,0,16,158,1,0,0,0,18,160,1,0,0,0,20,162,1,0,0,
		0,22,164,1,0,0,0,24,166,1,0,0,0,26,168,1,0,0,0,28,170,1,0,0,0,30,172,1,
		0,0,0,32,174,1,0,0,0,34,176,1,0,0,0,36,178,1,0,0,0,38,180,1,0,0,0,40,182,
		1,0,0,0,42,184,1,0,0,0,44,186,1,0,0,0,46,188,1,0,0,0,48,190,1,0,0,0,50,
		200,1,0,0,0,52,202,1,0,0,0,54,212,1,0,0,0,56,214,1,0,0,0,58,222,1,0,0,
		0,60,256,1,0,0,0,62,284,1,0,0,0,64,286,1,0,0,0,66,290,1,0,0,0,68,295,1,
		0,0,0,70,323,1,0,0,0,72,326,1,0,0,0,74,339,1,0,0,0,76,344,1,0,0,0,78,346,
		1,0,0,0,80,365,1,0,0,0,82,367,1,0,0,0,84,369,1,0,0,0,86,376,1,0,0,0,88,
		378,1,0,0,0,90,384,1,0,0,0,92,386,1,0,0,0,94,400,1,0,0,0,96,417,1,0,0,
		0,98,432,1,0,0,0,100,440,1,0,0,0,102,451,1,0,0,0,104,472,1,0,0,0,106,474,
		1,0,0,0,108,496,1,0,0,0,110,513,1,0,0,0,112,517,1,0,0,0,114,537,1,0,0,
		0,116,540,1,0,0,0,118,557,1,0,0,0,120,561,1,0,0,0,122,568,1,0,0,0,124,
		573,1,0,0,0,126,580,1,0,0,0,128,597,1,0,0,0,130,602,1,0,0,0,132,619,1,
		0,0,0,134,650,1,0,0,0,136,667,1,0,0,0,138,672,1,0,0,0,140,689,1,0,0,0,
		142,143,5,34,0,0,143,1,1,0,0,0,144,145,5,65,0,0,145,3,1,0,0,0,146,147,
		5,63,0,0,147,5,1,0,0,0,148,149,5,3,0,0,149,7,1,0,0,0,150,151,5,2,0,0,151,
		9,1,0,0,0,152,153,5,5,0,0,153,11,1,0,0,0,154,155,7,0,0,0,155,13,1,0,0,
		0,156,157,7,1,0,0,157,15,1,0,0,0,158,159,5,4,0,0,159,17,1,0,0,0,160,161,
		5,6,0,0,161,19,1,0,0,0,162,163,5,7,0,0,163,21,1,0,0,0,164,165,5,8,0,0,
		165,23,1,0,0,0,166,167,5,9,0,0,167,25,1,0,0,0,168,169,5,10,0,0,169,27,
		1,0,0,0,170,171,5,12,0,0,171,29,1,0,0,0,172,173,5,39,0,0,173,31,1,0,0,
		0,174,175,5,38,0,0,175,33,1,0,0,0,176,177,5,53,0,0,177,35,1,0,0,0,178,
		179,5,54,0,0,179,37,1,0,0,0,180,181,5,61,0,0,181,39,1,0,0,0,182,183,5,
		58,0,0,183,41,1,0,0,0,184,185,5,60,0,0,185,43,1,0,0,0,186,187,5,49,0,0,
		187,45,1,0,0,0,188,189,5,51,0,0,189,47,1,0,0,0,190,191,5,50,0,0,191,49,
		1,0,0,0,192,194,3,34,17,0,193,195,5,56,0,0,194,193,1,0,0,0,194,195,1,0,
		0,0,195,201,1,0,0,0,196,198,3,36,18,0,197,199,5,57,0,0,198,197,1,0,0,0,
		198,199,1,0,0,0,199,201,1,0,0,0,200,192,1,0,0,0,200,196,1,0,0,0,201,51,
		1,0,0,0,202,206,5,43,0,0,203,204,3,6,3,0,204,205,5,58,0,0,205,207,1,0,
		0,0,206,203,1,0,0,0,206,207,1,0,0,0,207,53,1,0,0,0,208,213,3,44,22,0,209,
		213,3,50,25,0,210,213,3,38,19,0,211,213,3,42,21,0,212,208,1,0,0,0,212,
		209,1,0,0,0,212,210,1,0,0,0,212,211,1,0,0,0,213,55,1,0,0,0,214,220,3,12,
		6,0,215,218,3,6,3,0,216,219,3,40,20,0,217,219,3,34,17,0,218,216,1,0,0,
		0,218,217,1,0,0,0,219,221,1,0,0,0,220,215,1,0,0,0,220,221,1,0,0,0,221,
		57,1,0,0,0,222,234,7,2,0,0,223,227,3,6,3,0,224,226,5,1,0,0,225,224,1,0,
		0,0,226,229,1,0,0,0,227,225,1,0,0,0,227,228,1,0,0,0,228,232,1,0,0,0,229,
		227,1,0,0,0,230,233,3,40,20,0,231,233,3,34,17,0,232,230,1,0,0,0,232,231,
		1,0,0,0,233,235,1,0,0,0,234,223,1,0,0,0,234,235,1,0,0,0,235,236,1,0,0,
		0,236,240,5,22,0,0,237,239,5,1,0,0,238,237,1,0,0,0,239,242,1,0,0,0,240,
		238,1,0,0,0,240,241,1,0,0,0,241,254,1,0,0,0,242,240,1,0,0,0,243,247,3,
		6,3,0,244,246,5,1,0,0,245,244,1,0,0,0,246,249,1,0,0,0,247,245,1,0,0,0,
		247,248,1,0,0,0,248,252,1,0,0,0,249,247,1,0,0,0,250,253,3,40,20,0,251,
		253,3,34,17,0,252,250,1,0,0,0,252,251,1,0,0,0,253,255,1,0,0,0,254,243,
		1,0,0,0,254,255,1,0,0,0,255,59,1,0,0,0,256,257,5,23,0,0,257,258,3,100,
		50,0,258,264,5,24,0,0,259,262,3,6,3,0,260,263,3,40,20,0,261,263,3,34,17,
		0,262,260,1,0,0,0,262,261,1,0,0,0,263,265,1,0,0,0,264,259,1,0,0,0,264,
		265,1,0,0,0,265,61,1,0,0,0,266,267,5,23,0,0,267,268,3,100,50,0,268,269,
		5,35,0,0,269,270,5,24,0,0,270,285,1,0,0,0,271,272,5,23,0,0,272,275,3,100,
		50,0,273,274,5,35,0,0,274,276,3,100,50,0,275,273,1,0,0,0,276,277,1,0,0,
		0,277,275,1,0,0,0,277,278,1,0,0,0,278,280,1,0,0,0,279,281,5,35,0,0,280,
		279,1,0,0,0,280,281,1,0,0,0,281,282,1,0,0,0,282,283,5,24,0,0,283,285,1,
		0,0,0,284,266,1,0,0,0,284,271,1,0,0,0,285,63,1,0,0,0,286,287,7,3,0,0,287,
		65,1,0,0,0,288,291,3,50,25,0,289,291,3,38,19,0,290,288,1,0,0,0,290,289,
		1,0,0,0,291,67,1,0,0,0,292,294,3,74,37,0,293,292,1,0,0,0,294,297,1,0,0,
		0,295,293,1,0,0,0,295,296,1,0,0,0,296,301,1,0,0,0,297,295,1,0,0,0,298,
		300,3,114,57,0,299,298,1,0,0,0,300,303,1,0,0,0,301,299,1,0,0,0,301,302,
		1,0,0,0,302,304,1,0,0,0,303,301,1,0,0,0,304,305,3,42,21,0,305,306,5,20,
		0,0,306,307,3,66,33,0,307,69,1,0,0,0,308,324,5,28,0,0,309,310,5,29,0,0,
		310,315,3,68,34,0,311,312,5,35,0,0,312,314,3,68,34,0,313,311,1,0,0,0,314,
		317,1,0,0,0,315,313,1,0,0,0,315,316,1,0,0,0,316,319,1,0,0,0,317,315,1,
		0,0,0,318,320,5,35,0,0,319,318,1,0,0,0,319,320,1,0,0,0,320,321,1,0,0,0,
		321,322,5,30,0,0,322,324,1,0,0,0,323,308,1,0,0,0,323,309,1,0,0,0,324,71,
		1,0,0,0,325,327,3,74,37,0,326,325,1,0,0,0,326,327,1,0,0,0,327,328,1,0,
		0,0,328,329,3,24,12,0,329,330,5,26,0,0,330,331,3,64,32,0,331,333,5,27,
		0,0,332,334,3,42,21,0,333,332,1,0,0,0,333,334,1,0,0,0,334,335,1,0,0,0,
		335,336,3,70,35,0,336,73,1,0,0,0,337,340,3,48,24,0,338,340,3,46,23,0,339,
		337,1,0,0,0,339,338,1,0,0,0,340,342,1,0,0,0,341,343,3,114,57,0,342,341,
		1,0,0,0,342,343,1,0,0,0,343,75,1,0,0,0,344,345,5,65,0,0,345,77,1,0,0,0,
		346,347,3,4,2,0,347,348,3,92,46,0,348,79,1,0,0,0,349,366,5,25,0,0,350,
		351,5,26,0,0,351,357,3,100,50,0,352,353,3,0,0,0,353,354,3,100,50,0,354,
		356,1,0,0,0,355,352,1,0,0,0,356,359,1,0,0,0,357,355,1,0,0,0,357,358,1,
		0,0,0,358,361,1,0,0,0,359,357,1,0,0,0,360,362,3,0,0,0,361,360,1,0,0,0,
		361,362,1,0,0,0,362,363,1,0,0,0,363,364,5,27,0,0,364,366,1,0,0,0,365,349,
		1,0,0,0,365,350,1,0,0,0,366,81,1,0,0,0,367,368,7,4,0,0,368,83,1,0,0,0,
		369,373,3,86,43,0,370,372,3,86,43,0,371,370,1,0,0,0,372,375,1,0,0,0,373,
		371,1,0,0,0,373,374,1,0,0,0,374,85,1,0,0,0,375,373,1,0,0,0,376,377,7,5,
		0,0,377,87,1,0,0,0,378,379,5,23,0,0,379,380,3,84,42,0,380,381,5,24,0,0,
		381,89,1,0,0,0,382,385,3,82,41,0,383,385,3,88,44,0,384,382,1,0,0,0,384,
		383,1,0,0,0,385,91,1,0,0,0,386,387,5,23,0,0,387,392,3,90,45,0,388,389,
		5,35,0,0,389,391,3,90,45,0,390,388,1,0,0,0,391,394,1,0,0,0,392,390,1,0,
		0,0,392,393,1,0,0,0,393,396,1,0,0,0,394,392,1,0,0,0,395,397,5,35,0,0,396,
		395,1,0,0,0,396,397,1,0,0,0,397,398,1,0,0,0,398,399,5,24,0,0,399,93,1,
		0,0,0,400,401,3,92,46,0,401,95,1,0,0,0,402,418,5,31,0,0,403,404,5,32,0,
		0,404,409,3,100,50,0,405,406,5,35,0,0,406,408,3,100,50,0,407,405,1,0,0,
		0,408,411,1,0,0,0,409,407,1,0,0,0,409,410,1,0,0,0,410,413,1,0,0,0,411,
		409,1,0,0,0,412,414,5,35,0,0,413,412,1,0,0,0,413,414,1,0,0,0,414,415,1,
		0,0,0,415,416,5,33,0,0,416,418,1,0,0,0,417,402,1,0,0,0,417,403,1,0,0,0,
		418,97,1,0,0,0,419,433,3,14,7,0,420,433,3,52,26,0,421,433,3,54,27,0,422,
		433,3,56,28,0,423,433,3,58,29,0,424,433,3,60,30,0,425,433,3,62,31,0,426,
		433,3,72,36,0,427,433,3,138,69,0,428,433,3,76,38,0,429,433,3,78,39,0,430,
		433,3,80,40,0,431,433,3,94,47,0,432,419,1,0,0,0,432,420,1,0,0,0,432,421,
		1,0,0,0,432,422,1,0,0,0,432,423,1,0,0,0,432,424,1,0,0,0,432,425,1,0,0,
		0,432,426,1,0,0,0,432,427,1,0,0,0,432,428,1,0,0,0,432,429,1,0,0,0,432,
		430,1,0,0,0,432,431,1,0,0,0,433,435,1,0,0,0,434,436,5,35,0,0,435,434,1,
		0,0,0,435,436,1,0,0,0,436,99,1,0,0,0,437,439,3,114,57,0,438,437,1,0,0,
		0,439,442,1,0,0,0,440,438,1,0,0,0,440,441,1,0,0,0,441,443,1,0,0,0,442,
		440,1,0,0,0,443,448,3,98,49,0,444,447,3,92,46,0,445,447,3,96,48,0,446,
		444,1,0,0,0,446,445,1,0,0,0,447,450,1,0,0,0,448,446,1,0,0,0,448,449,1,
		0,0,0,449,101,1,0,0,0,450,448,1,0,0,0,451,456,3,112,56,0,452,453,5,35,
		0,0,453,455,3,112,56,0,454,452,1,0,0,0,455,458,1,0,0,0,456,454,1,0,0,0,
		456,457,1,0,0,0,457,103,1,0,0,0,458,456,1,0,0,0,459,462,3,42,21,0,460,
		462,3,38,19,0,461,459,1,0,0,0,461,460,1,0,0,0,462,463,1,0,0,0,463,464,
		5,20,0,0,464,465,3,112,56,0,465,473,1,0,0,0,466,469,3,42,21,0,467,469,
		3,38,19,0,468,466,1,0,0,0,468,467,1,0,0,0,469,470,1,0,0,0,470,471,3,110,
		55,0,471,473,1,0,0,0,472,461,1,0,0,0,472,468,1,0,0,0,473,105,1,0,0,0,474,
		479,3,104,52,0,475,476,5,35,0,0,476,478,3,104,52,0,477,475,1,0,0,0,478,
		481,1,0,0,0,479,477,1,0,0,0,479,480,1,0,0,0,480,107,1,0,0,0,481,479,1,
		0,0,0,482,484,3,102,51,0,483,485,5,35,0,0,484,483,1,0,0,0,484,485,1,0,
		0,0,485,497,1,0,0,0,486,488,3,106,53,0,487,489,5,35,0,0,488,487,1,0,0,
		0,488,489,1,0,0,0,489,497,1,0,0,0,490,491,3,102,51,0,491,492,5,35,0,0,
		492,494,3,106,53,0,493,495,5,35,0,0,494,493,1,0,0,0,494,495,1,0,0,0,495,
		497,1,0,0,0,496,482,1,0,0,0,496,486,1,0,0,0,496,490,1,0,0,0,497,109,1,
		0,0,0,498,500,5,26,0,0,499,501,3,108,54,0,500,499,1,0,0,0,500,501,1,0,
		0,0,501,502,1,0,0,0,502,514,5,27,0,0,503,505,5,23,0,0,504,506,3,108,54,
		0,505,504,1,0,0,0,505,506,1,0,0,0,506,507,1,0,0,0,507,514,5,24,0,0,508,
		510,5,29,0,0,509,511,3,108,54,0,510,509,1,0,0,0,510,511,1,0,0,0,511,512,
		1,0,0,0,512,514,5,30,0,0,513,498,1,0,0,0,513,503,1,0,0,0,513,508,1,0,0,
		0,514,111,1,0,0,0,515,518,3,100,50,0,516,518,3,110,55,0,517,515,1,0,0,
		0,517,516,1,0,0,0,518,113,1,0,0,0,519,520,5,21,0,0,520,521,5,23,0,0,521,
		522,3,42,21,0,522,523,5,24,0,0,523,538,1,0,0,0,524,525,5,21,0,0,525,526,
		5,23,0,0,526,527,3,42,21,0,527,528,5,20,0,0,528,529,3,112,56,0,529,530,
		5,24,0,0,530,538,1,0,0,0,531,532,5,21,0,0,532,533,5,23,0,0,533,534,3,42,
		21,0,534,535,3,110,55,0,535,536,5,24,0,0,536,538,1,0,0,0,537,519,1,0,0,
		0,537,524,1,0,0,0,537,531,1,0,0,0,538,115,1,0,0,0,539,541,3,74,37,0,540,
		539,1,0,0,0,540,541,1,0,0,0,541,545,1,0,0,0,542,544,3,114,57,0,543,542,
		1,0,0,0,544,547,1,0,0,0,545,543,1,0,0,0,545,546,1,0,0,0,546,548,1,0,0,
		0,547,545,1,0,0,0,548,549,3,28,14,0,549,550,3,4,2,0,550,552,3,92,46,0,
		551,553,3,128,64,0,552,551,1,0,0,0,552,553,1,0,0,0,553,554,1,0,0,0,554,
		555,5,11,0,0,555,556,3,100,50,0,556,117,1,0,0,0,557,558,3,20,10,0,558,
		559,3,2,1,0,559,560,3,136,68,0,560,119,1,0,0,0,561,562,5,9,0,0,562,563,
		5,26,0,0,563,564,3,72,36,0,564,565,5,27,0,0,565,566,3,2,1,0,566,567,3,
		70,35,0,567,121,1,0,0,0,568,571,3,22,11,0,569,572,3,120,60,0,570,572,3,
		118,59,0,571,569,1,0,0,0,571,570,1,0,0,0,572,123,1,0,0,0,573,574,3,26,
		13,0,574,578,3,2,1,0,575,576,3,8,4,0,576,577,3,42,21,0,577,579,1,0,0,0,
		578,575,1,0,0,0,578,579,1,0,0,0,579,125,1,0,0,0,580,581,5,60,0,0,581,127,
		1,0,0,0,582,598,5,31,0,0,583,584,5,32,0,0,584,589,3,126,63,0,585,586,5,
		35,0,0,586,588,3,126,63,0,587,585,1,0,0,0,588,591,1,0,0,0,589,587,1,0,
		0,0,589,590,1,0,0,0,590,593,1,0,0,0,591,589,1,0,0,0,592,594,5,35,0,0,593,
		592,1,0,0,0,593,594,1,0,0,0,594,595,1,0,0,0,595,596,5,33,0,0,596,598,1,
		0,0,0,597,582,1,0,0,0,597,583,1,0,0,0,598,129,1,0,0,0,599,601,3,74,37,
		0,600,599,1,0,0,0,601,604,1,0,0,0,602,600,1,0,0,0,602,603,1,0,0,0,603,
		605,1,0,0,0,604,602,1,0,0,0,605,606,3,18,9,0,606,608,3,42,21,0,607,609,
		3,128,64,0,608,607,1,0,0,0,608,609,1,0,0,0,609,610,1,0,0,0,610,611,5,20,
		0,0,611,612,3,100,50,0,612,131,1,0,0,0,613,620,5,61,0,0,614,620,5,60,0,
		0,615,616,5,23,0,0,616,617,3,100,50,0,617,618,5,24,0,0,618,620,1,0,0,0,
		619,613,1,0,0,0,619,614,1,0,0,0,619,615,1,0,0,0,620,133,1,0,0,0,621,623,
		3,74,37,0,622,621,1,0,0,0,623,626,1,0,0,0,624,622,1,0,0,0,624,625,1,0,
		0,0,625,630,1,0,0,0,626,624,1,0,0,0,627,629,3,114,57,0,628,627,1,0,0,0,
		629,632,1,0,0,0,630,628,1,0,0,0,630,631,1,0,0,0,631,633,1,0,0,0,632,630,
		1,0,0,0,633,635,3,132,66,0,634,636,3,16,8,0,635,634,1,0,0,0,635,636,1,
		0,0,0,636,637,1,0,0,0,637,638,5,37,0,0,638,639,3,100,50,0,639,651,1,0,
		0,0,640,642,3,114,57,0,641,640,1,0,0,0,642,645,1,0,0,0,643,641,1,0,0,0,
		643,644,1,0,0,0,644,647,1,0,0,0,645,643,1,0,0,0,646,648,3,32,16,0,647,
		646,1,0,0,0,647,648,1,0,0,0,648,649,1,0,0,0,649,651,3,100,50,0,650,624,
		1,0,0,0,650,643,1,0,0,0,651,135,1,0,0,0,652,668,5,28,0,0,653,654,5,29,
		0,0,654,659,3,134,67,0,655,656,5,35,0,0,656,658,3,134,67,0,657,655,1,0,
		0,0,658,661,1,0,0,0,659,657,1,0,0,0,659,660,1,0,0,0,660,663,1,0,0,0,661,
		659,1,0,0,0,662,664,5,35,0,0,663,662,1,0,0,0,663,664,1,0,0,0,664,665,1,
		0,0,0,665,666,5,30,0,0,666,668,1,0,0,0,667,652,1,0,0,0,667,653,1,0,0,0,
		668,137,1,0,0,0,669,671,3,74,37,0,670,669,1,0,0,0,671,674,1,0,0,0,672,
		670,1,0,0,0,672,673,1,0,0,0,673,675,1,0,0,0,674,672,1,0,0,0,675,677,3,
		20,10,0,676,678,3,42,21,0,677,676,1,0,0,0,677,678,1,0,0,0,678,679,1,0,
		0,0,679,680,3,136,68,0,680,139,1,0,0,0,681,688,3,138,69,0,682,688,3,72,
		36,0,683,688,3,130,65,0,684,688,3,124,62,0,685,688,3,122,61,0,686,688,
		3,116,58,0,687,681,1,0,0,0,687,682,1,0,0,0,687,683,1,0,0,0,687,684,1,0,
		0,0,687,685,1,0,0,0,687,686,1,0,0,0,688,691,1,0,0,0,689,687,1,0,0,0,689,
		690,1,0,0,0,690,141,1,0,0,0,691,689,1,0,0,0,83,194,198,200,206,212,218,
		220,227,232,234,240,247,252,254,262,264,277,280,284,290,295,301,315,319,
		323,326,333,339,342,357,361,365,373,384,392,396,409,413,417,432,435,440,
		446,448,456,461,468,472,479,484,488,494,496,500,505,510,513,517,537,540,
		545,552,571,578,589,593,597,602,608,619,624,630,635,643,647,650,659,663,
		667,672,677,687,689
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
